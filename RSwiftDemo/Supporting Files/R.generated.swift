//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap(Locale.init) ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map(Locale.init)
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 2 storyboards.
  struct storyboard {
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `Main`.
    static let main = _R.storyboard.main()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Main", bundle: ...)`
    static func main(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.main)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 1 colors.
  struct color {
    /// Color `PaleGray`.
    static let paleGray = Rswift.ColorResource(bundle: R.hostingBundle, name: "PaleGray")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "PaleGray", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func paleGray(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.paleGray, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 6 files.
  struct file {
    /// Resource file `AveriaLibre-B.ttf`.
    static let averiaLibreBTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AveriaLibre-B", pathExtension: "ttf")
    /// Resource file `AveriaLibre-BI.ttf`.
    static let averiaLibreBITtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AveriaLibre-BI", pathExtension: "ttf")
    /// Resource file `AveriaLibre-L.ttf`.
    static let averiaLibreLTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AveriaLibre-L", pathExtension: "ttf")
    /// Resource file `AveriaLibre.ttf`.
    static let averiaLibreTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "AveriaLibre", pathExtension: "ttf")
    /// Resource file `GdyBkltter1911.ttf`.
    static let gdyBkltter1911Ttf = Rswift.FileResource(bundle: R.hostingBundle, name: "GdyBkltter1911", pathExtension: "ttf")
    /// Resource file `notification.mp3`.
    static let notificationMp3 = Rswift.FileResource(bundle: R.hostingBundle, name: "notification", pathExtension: "mp3")

    /// `bundle.url(forResource: "AveriaLibre", withExtension: "ttf")`
    static func averiaLibreTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.averiaLibreTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AveriaLibre-B", withExtension: "ttf")`
    static func averiaLibreBTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.averiaLibreBTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AveriaLibre-BI", withExtension: "ttf")`
    static func averiaLibreBITtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.averiaLibreBITtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "AveriaLibre-L", withExtension: "ttf")`
    static func averiaLibreLTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.averiaLibreLTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "GdyBkltter1911", withExtension: "ttf")`
    static func gdyBkltter1911Ttf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.gdyBkltter1911Ttf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "notification", withExtension: "mp3")`
    static func notificationMp3(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.notificationMp3
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 5 fonts.
  struct font: Rswift.Validatable {
    /// Font `AveriaLibre-BoldItalic`.
    static let averiaLibreBoldItalic = Rswift.FontResource(fontName: "AveriaLibre-BoldItalic")
    /// Font `AveriaLibre-Bold`.
    static let averiaLibreBold = Rswift.FontResource(fontName: "AveriaLibre-Bold")
    /// Font `AveriaLibre-Light`.
    static let averiaLibreLight = Rswift.FontResource(fontName: "AveriaLibre-Light")
    /// Font `AveriaLibre-Regular`.
    static let averiaLibreRegular = Rswift.FontResource(fontName: "AveriaLibre-Regular")
    /// Font `GoudyBookletter1911`.
    static let goudyBookletter1911 = Rswift.FontResource(fontName: "GoudyBookletter1911")

    /// `UIFont(name: "AveriaLibre-Bold", size: ...)`
    static func averiaLibreBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: averiaLibreBold, size: size)
    }

    /// `UIFont(name: "AveriaLibre-BoldItalic", size: ...)`
    static func averiaLibreBoldItalic(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: averiaLibreBoldItalic, size: size)
    }

    /// `UIFont(name: "AveriaLibre-Light", size: ...)`
    static func averiaLibreLight(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: averiaLibreLight, size: size)
    }

    /// `UIFont(name: "AveriaLibre-Regular", size: ...)`
    static func averiaLibreRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: averiaLibreRegular, size: size)
    }

    /// `UIFont(name: "GoudyBookletter1911", size: ...)`
    static func goudyBookletter1911(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: goudyBookletter1911, size: size)
    }

    static func validate() throws {
      if R.font.averiaLibreBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AveriaLibre-Bold' could not be loaded, is 'AveriaLibre-B.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.averiaLibreBoldItalic(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AveriaLibre-BoldItalic' could not be loaded, is 'AveriaLibre-BI.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.averiaLibreLight(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AveriaLibre-Light' could not be loaded, is 'AveriaLibre-L.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.averiaLibreRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'AveriaLibre-Regular' could not be loaded, is 'AveriaLibre.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.goudyBookletter1911(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'GoudyBookletter1911' could not be loaded, is 'GdyBkltter1911.ttf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 1 images.
  struct image {
    /// Image `menu-default-profile`.
    static let menuDefaultProfile = Rswift.ImageResource(bundle: R.hostingBundle, name: "menu-default-profile")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "menu-default-profile", bundle: ..., traitCollection: ...)`
    static func menuDefaultProfile(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.menuDefaultProfile, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 1 nibs.
  struct nib {
    /// Nib `MyTableViewCell`.
    static let myTableViewCell = _R.nib._MyTableViewCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "MyTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.myTableViewCell) instead")
    static func myTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.myTableViewCell)
    }
    #endif

    static func myTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> MyTableViewCell? {
      return R.nib.myTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? MyTableViewCell
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 1 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `MyTableViewCell`.
    static let myTableViewCell: Rswift.ReuseIdentifier<MyTableViewCell> = Rswift.ReuseIdentifier(identifier: "MyTableViewCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 1 localization tables.
  struct string {
    /// This `R.string.localizable` struct is generated, and contains static references to 11 localization keys.
    struct localizable {
      /// en translation: %#@localized_format_key@
      ///
      /// Locales: en, zh-Hant
      static let item_count = Rswift.StringResource(key: "item_count", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: %1$d piece of %2$@ (Total HK$%3$.2f)
      ///
      /// Locales: en, zh-Hant
      static let placeholder_test = Rswift.StringResource(key: "placeholder_test", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: %d items
      ///
      /// Locales: en, zh-Hant
      static let item_countOther = Rswift.StringResource(key: "item_count.other", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: 1 item
      ///
      /// Locales: en
      static let item_countOne = Rswift.StringResource(key: "item_count.one", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: Cancel
      ///
      /// Locales: en, zh-Hant
      static let cancel = Rswift.StringResource(key: "cancel", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: Main
      ///
      /// Locales: en, zh-Hant
      static let main_title = Rswift.StringResource(key: "main_title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: OK
      ///
      /// Locales: en, zh-Hant
      static let ok = Rswift.StringResource(key: "ok", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: Yes
      ///
      /// Locales: en, zh-Hant
      static let yes = Rswift.StringResource(key: "yes", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: dd MMM
      ///
      /// Locales: en, zh-Hant
      static let datetime_format_dm = Rswift.StringResource(key: "datetime_format_dm", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: dd MMM HH:mm a
      ///
      /// Locales: en, zh-Hant
      static let datetime_format_dm_hm = Rswift.StringResource(key: "datetime_format_dm_hm", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)
      /// en translation: dd MMM yyyy, hh:mm a
      ///
      /// Locales: en, zh-Hant
      static let datetime_format_dmy_hm = Rswift.StringResource(key: "datetime_format_dmy_hm", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "zh-Hant"], comment: nil)

      /// en translation: %#@localized_format_key@
      ///
      /// Locales: en, zh-Hant
      static func item_count(localized_format_key value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("item_count", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "item_count"
        }

        let format = NSLocalizedString("item_count", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %1$d piece of %2$@ (Total HK$%3$.2f)
      ///
      /// Locales: en, zh-Hant
      static func placeholder_test(_ value1: Int, _ value2: String, _ value3: Double, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("placeholder_test", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2, value3)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "placeholder_test"
        }

        let format = NSLocalizedString("placeholder_test", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2, value3)
      }

      /// en translation: %d items
      ///
      /// Locales: en, zh-Hant
      static func item_countOther(_ value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("item_count.other", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "item_count.other"
        }

        let format = NSLocalizedString("item_count.other", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: 1 item
      ///
      /// Locales: en
      static func item_countOne(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("item_count.one", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "item_count.one"
        }

        return NSLocalizedString("item_count.one", bundle: bundle, comment: "")
      }

      /// en translation: Cancel
      ///
      /// Locales: en, zh-Hant
      static func cancel(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("cancel", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "cancel"
        }

        return NSLocalizedString("cancel", bundle: bundle, comment: "")
      }

      /// en translation: Main
      ///
      /// Locales: en, zh-Hant
      static func main_title(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("main_title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "main_title"
        }

        return NSLocalizedString("main_title", bundle: bundle, comment: "")
      }

      /// en translation: OK
      ///
      /// Locales: en, zh-Hant
      static func ok(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ok", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ok"
        }

        return NSLocalizedString("ok", bundle: bundle, comment: "")
      }

      /// en translation: Yes
      ///
      /// Locales: en, zh-Hant
      static func yes(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("yes", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "yes"
        }

        return NSLocalizedString("yes", bundle: bundle, comment: "")
      }

      /// en translation: dd MMM
      ///
      /// Locales: en, zh-Hant
      static func datetime_format_dm(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("datetime_format_dm", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "datetime_format_dm"
        }

        return NSLocalizedString("datetime_format_dm", bundle: bundle, comment: "")
      }

      /// en translation: dd MMM HH:mm a
      ///
      /// Locales: en, zh-Hant
      static func datetime_format_dm_hm(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("datetime_format_dm_hm", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "datetime_format_dm_hm"
        }

        return NSLocalizedString("datetime_format_dm_hm", bundle: bundle, comment: "")
      }

      /// en translation: dd MMM yyyy, hh:mm a
      ///
      /// Locales: en, zh-Hant
      static func datetime_format_dmy_hm(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("datetime_format_dmy_hm", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "datetime_format_dmy_hm"
        }

        return NSLocalizedString("datetime_format_dmy_hm", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib {
    struct _MyTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = MyTableViewCell

      let bundle = R.hostingBundle
      let identifier = "MyTableViewCell"
      let name = "MyTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> MyTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? MyTableViewCell
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try main.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct main: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = ViewController

      let bundle = R.hostingBundle
      let name = "Main"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
